---
title: 各种优化方法整理总结
sitemap: true
categories: 深度学习
date: 2018-10-02 16:35:12
tags:
- 深度学习
---

<span id = "简述各种优化方法的概念及其优缺点">
# 简述各种优化方法的概念及其优缺点

$$\theta_t = \theta_{t-1} + \Delta \theta_t$$

| 名称 | 公式 | 优化方法简述 | 优点 | 缺点 |
| :---: | :---: | :--- | :--- | :--- |
| SGD | $g_t = \nabla_{\theta_{t-1}} f(\theta_{t-1})$ <br> $\Delta \theta_t = - \eta \times g_t$ | 每一次都计算mini-batch的梯度, 然后对参数进行更新. 公式中的 $\eta$ 是学习率, $g_t$ 是当前 batch 的梯度 | 收敛速度快 | (1) 因为要兼顾整个神经网络中所有参数的训练效果, 因此对学习率的选择比较敏感. (2) SGD 容易收敛到局部最优, 并且在某些情况下容易被困在鞍点, 需要使用合适的初始化和步长; (3) 参数的更新仅仅依赖于当前 batch 中的数据, 当数据波动大时, 更新往往不够稳定 |
| Momentum  | $g_t = \nabla_{\theta_{t-1}} f(\theta_{t-1})$ <br> $m_t = \mu \times m_{t-1} + g_t$ <br> $\Delta \theta_t = -\eta \times m_t$  | 公式中的 $\mu$ 为动量因子, 通常取值 0.9 或 0.99, 借助于物理学里面动量的概念, 通过动量的积累来在相关方向上加速 SGD 优化速度, 抑制震荡, 同时有助于跳出局部最优, 进而加快收敛| (1) 下降初期, 下降方向一致, 有助于加速下降; (2) 下降中后期, 在局部最小值附近, 有助于跳出局部最优; (3) 在梯度改变方向时, 能够降低更新幅度, 减小震荡 | 暂无 |
| Nesterov  |  $g_t=\nabla_{\theta_{t-1}} f(\theta_{t-1} - \eta \times \mu \times m_{t-1})$ <br> $m_t = \mu \times m_{t-1} + g_t$ <br> $\Delta \theta_t = -\eta \times m_t$ | 可以看出, Nesterov 与 Momentum 公式的区别在于, 前者不是在当前的位置上求梯度, 而是根据本来计划要走的那一步提前前进一步以后, 再在新的位置上求梯度, 然后对这个新求得的梯度进行 Momentum 梯度下降计算 | (1) 站在下一步的位置看看, 再进行更新, 使得梯度更新方向更具前瞻性 | (1) 增加了计算量|
| Adagrad  |  $n_t = n_{t-1} + g^2_t$ <br> $\Delta \theta_t = -\frac{\eta}{\sqrt{n_t + \epsilon}} \times g_t$ |  Adagrad相当于在学习率前面乘了一个约束项 $\frac{1}{\sqrt {n_t + \epsilon}}$, 该约束项会随着算法的不断迭代而越来越大, 那么对应学习率就会越来越小, 也就是说 Adagrad 算法在开始时是大步前进的, 而在后面则会减小步伐, 缓慢收敛 | (1) 在整个更新期间学习率不是固定的, 会随着训练过程变化; (2) 适合面对稀疏梯度 | (1) 仍然依赖于一个人工设置的全局学习率; (2) 中后期, 分母上的梯度放平累加和会越来越大, 使得更新提早停滞, 训练提前结束 |
| AdaDelta  | $Eg^2_t = \rho\times Eg^2_{t-1} + (1-\rho)\times g^2_t$ <br> $\Delta \theta_t = -\frac{\eta}{\sqrt{Eg^2_t + \epsilon}} g_t$ <br> $= -\frac{\eta}{RMS[g]_t} g_t$ <br> $= -\frac{RMS[\Delta\theta]_{t-1}}{RMS[g]_t} g_t$ |  Adadelta是对Adagrad的扩展, 和 Adagrad 相比, 其改进是将分母约束项换成了过去的梯度平方的衰减平均值, 相当于梯度的均方根(root mean squared, RMS), 此外, 如果将学习率也换成 $RMS[\Delta \theta]$ 的话, 甚至可以不用设置学习率了 | (1) 对 Adagrad 的扩展, 约束项不容易产生太大值而使得更新提早结束; (2) 无需人工设置学习率 | (1) 训练后期会反复在局部最小值附近抖动(why?) |
|  RMSprop |  $Eg^2_t = \rho\times Eg^2_{t-1} + (1-\rho)\times g^2_t$ <br> $\Delta \theta_t = -\frac{\eta}{\sqrt{Eg^2_t + \epsilon}} g_t$ |  RMSprop可以算作是Adadelta的一个特例, 可以看出 RMSprop 仍然需要设置全局学习率 | (1) Adadelta 的特例, 也是对学习率添加约束, 适合处理非平稳目标, 对 RNN 效果较好 | (1) 依然需要依赖于全局学习率 |
| Adam  | $m_t = \mu \times m_{t-1} + (1-\mu) \times g_t$ <br> $n_t = \nu \times n_{t-1} + (1 - \nu) \times g^2_t$ <br> $\hat m_t = \frac{m_t}{1-\mu_t}$ <br> $\hat n_t = \frac{n_t}{1- \nu_t}$ <br> $\Delta \theta_t = -\frac{\hat m_t}{\sqrt{\hat n_t} + \epsilon} \times \eta$ |  Adam本质上是带有动量项的 RMSprop, 它利用 **修正后的** 梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率. 公式中, $m_t, n_t$ 分别是对梯度的一阶矩估计和二阶矩估计, 可以看做是对期望 $E g_t$, $E g^2_t$ 的估计, $\hat m_t$, $\hat n_t$ 是对 $m_t$, $n_t$ 的校正, 这样可以近似为对期望的无偏估计 | (1) 经过偏置校正后, 每一次迭代学习率都有一个确定的范围, 使得参数更新比较平稳; (2) 结合了 Adagrad 善于处理稀疏梯度和 RMSprop 善于处理非平稳目标的有点; (3) 对内存需求较小; (4) 适用于大多非凸优化, 适用于大数据集和高维空间 | |
|  Adamax |  $n_t = max(\nu \times, abs(g_t))$ <br> $\Delta x = -\frac{\hat m_t}{n_t + \epsilon}\times\eta$ | Adamax 是 Adam 的一种变体, 此方法对学习率的上限提供了一个更简单的范围, 可以看出, 学习率的边界范围更加简单 | | |
|  Nadam |  ...  | ... | | |

<span id = "简述 Adam 中使用的指数加权滑动平均法">
# 简述 Adam 中使用的指数加权滑动平均法

加权滑动平均法, 就是对观察值分别属于不同的权重, 按不同的权重来求最终的滑动平均值.  而指数加权滑动平均法就是指各个观察值的加权系数随着时间呈指数递减, 越靠近当前时刻的观察值权重越大. 公式如下:

$$v_t = \beta v_{t-1} + (1 - \beta) \theta_t$$

上式中, $\theta_t$ 代表当前时刻的观察值, 系数 $\beta$ 代表加权下降的速率, 其值越小下降的越快, $v_t$ 代表当前时刻的指数加权滑动平均值.

PS: 在数学中一般会以 $\frac{1}{e}$ 来作为一个临界值, 小于该值的加权系数对应的值不作考虑. 因此, 当 $\beta = 0.9$ 时, $0.9^{10}$ 约等于 $\frac{1}{e}$, 认为此时是约 10 个数值的加权平均.

**偏差修正:** 当初始化 $v_0 = 0$ 时, 由于初始化的值太小, 导致初期的滑动平均值偏小, 随着时间的增长, 初期的值影响减小, 滑动平均值才逐渐正常. 为了让初期的滑动平均值也相对正常, 我们利用下面的式子进行修正:

$$v_t = \frac{\beta v_{t-1} + (1 - \beta)\theta_t}{1 - \beta^t}$$

<span id = "各种优化方法的源码实现">
# 各种优化方法的源码实现

# 深入解析各个损失函数的优缺点

## SGD

**缺点:**

## Momentum

**特点:**
1. 下降初期时, 由于动量因子的存在使得可以加速网络的训练速度
2. 当遇到鞍点时, 梯度虽然为零, 但是动量不为零, 可以轻松的跳出鞍点
3. 当梯度改变方向时, 动量可以抑制震荡, 加速网络收敛.

**缺点:** 需要人工设置学习率

## Nesterov

**特点:**
Nesterov 相比于 Momentum 来说, 提前走了一步, 因此, 它能够让算法提前看到前方的地形梯度, 如果前面的梯度比当前位置的梯度大, 那么就可以把步子迈的比原来大一些, 反之, 可以把步子迈的比原来小一些. 这个大一些, 小一些, 都是相对于原来不看前方梯度, 只看当前位置梯度的情况来说的.
另一个角度, 二阶导信息: https://zhuanlan.zhihu.com/p/22810533

**缺点:** 需要人工设置学习率

## Adagrad

**特点:**
可以根据梯度的大小动态的改变学习率的大小.

**缺点:**
1. 由公式可以看出, 扔依赖于人工设置一个全局的学习率
2. 约束项的初值设置的不合理的话, 会影响梯度的调节幅度.

## Adadelta

**特点:**
1. 可以动态改变学习率的大小
2. 无需设置全局的学习率


## RMSprop

实际上是 Adadelta 的变体, 从公式可以看出, 仍然需要设置全局学习率

## Adam(Adaptive Moment Estimation)

**特点:**
1. 结合了 Adagrad 善于处理稀疏梯度和 RMSprop 善于处理非平稳目标的有点
2. 对内存需要较小
3. 为不同的参数计算不同的自适应学习率
4. 也适用于大多非凸优化, 适用与大数据集和高维空间



损失平面等高线:

![](https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw1zh9xp8fj20hq0dtjuw.jpg)


鞍点处的比较:

![](https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw1zh9w3n9j20j90femz6.jpg)

# 损失函数选择经验

- 对于稀疏数据, 尽量使用学习率可自适应的优化方法, 因为自适应的优化方法对不同的参数会赋予不同的更新步长

// TODO 以下四点未确认正确性
- SGD通常训练时间更长, 但是在好的初始化和学习率调度方案的情况下, 结果更可靠
- 如果在意更快的收敛, 并且需要训练较深较复杂的网络时, 推荐使用学习率自适应的优化方法
- Adadelta, RMSprop, Adam是比较相近的算法, 在相似情况下表现差不多
- 在想使用带动量的RMSprop, 或者Adam的地方, 大多可以使用Nadam取得更好的效果


# 区别与联系

# 超参数


**learning rate:**

学习率决定了权值更新的速度, 设置的太大会使结果超过最优值, 太小会使下降速度过慢, 仅靠认为干预调整参数需要不断修改学习率, 十分不合理.

**weight decay:**

就是正则项, L1或L2正则项

**momentum:**



**learning rate decay:**

每经过一段迭代次数以后, 就会减小learning rate的大小.
